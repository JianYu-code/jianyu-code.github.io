<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>青青草原</title>
      <link href="2021/04/28/qing-qing-cao-yuan/"/>
      <url>2021/04/28/qing-qing-cao-yuan/</url>
      
        <content type="html"><![CDATA[<h2 id="青青草原"><a href="#青青草原" class="headerlink" title="青青草原"></a>青青草原</h2><blockquote><p>它穿着短袖出了门，<br>外面寒风刺骨，</p><p>他说，<br>杀不死的人，<br>杀不死的灵魂，<br>去他妈的精神不死，<br>狼死死的盯着这块肉，<br>什么羊都想当肉卷。</p><p>老羊把鲜嫩的肉卖给老狼，<br>换来鲜嫩的草，<br>羊仔瘦骨嶙峋，<br>嘴里高喊着精神至上，<br>灵魂不屈。</p><footer><strong>——————江洋</strong></footer></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
            <tag> 文案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我就那样站着入睡</title>
      <link href="2021/04/27/wo-jiu-na-yang-zhan-zhao-ru-shui/"/>
      <url>2021/04/27/wo-jiu-na-yang-zhan-zhao-ru-shui/</url>
      
        <content type="html"><![CDATA[<h2 id="我就那样站着入睡"><a href="#我就那样站着入睡" class="headerlink" title="我就那样站着入睡"></a>我就那样站着入睡</h2><blockquote><p>眼前的纸张微微发黄<br>我用钢笔在上面凿下深浅不一的黑<br>里面盛满打工的词汇<br>车间、流水线、机台、上岗证、加班、薪水…..<br>我被它们治得服服贴贴<br>我不会呐喊，不会反抗<br>不会控诉，不会埋怨<br>只默默地承受着疲惫，驻足时光之初<br>我只盼望每月十号那张灰色的薪资单<br>赐我以迟到的安慰<br>为此我必须磨去棱角，磨去语言<br>拒绝旷工，拒绝病假，拒绝事假<br>拒绝迟到，拒绝早退<br>流水线旁我站立如铁，双手如飞<br>多少白天，多少黑夜<br>我就那样，站着入睡</p><footer><strong>——————许立志</strong><cite>（富士康已故诗人）</cite></footer></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
            <tag> 文案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="2021/04/27/shu-ju-jie-gou/"/>
      <url>2021/04/27/shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<p>数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。<br><img src="https://cdn.jsdelivr.net/gh/JianYu-code/image/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg"></p><h2 id="第一章·绪论"><a href="#第一章·绪论" class="headerlink" title="第一章·绪论"></a>第一章·绪论</h2><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><blockquote><p>数据：数据是信息的载体，是用户输入字符能够被计算机所识别的符号集合</p><p>数据元素：数据元素是数据的基本单位，作为一个整体来看待和处理，一个数据元素是由多个数据项组成的</p><p>数据项：数据项是数据的最小单位</p><p>数据对象：数据对象是相同类型的数据元素的有限集合，是数据的一个子集</p><p>数据结构：数据结构是指数据之间存在一种或多种特定关系的数据元素集合</p><p>数据结构的三要素：逻辑结构丶存储结构丶数据的运算</p><p>逻辑结构：集合丶线性结构丶树形结构丶图状结构</p><p>线性结构：线性表、栈、队列</p><p>非线性结构：树、图、集合</p><p>存储结构：顺序存储丶链式存储丶索引存储丶散列存储</p><p>抽象数据类型：是一个数学模型以及定义在该模型上的一组操作，抽象数据类型的定义取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关</p><p>抽象数据类型三元组表示法：ADT=(D，S，P)，D是数据对象，S是D上的关系集，P是对D的基本操作集</p><p>算法：是对特定问题的求解步骤，指令集</p><p>算法的五大特性：有穷性丶确定性丶可行性（有效性）丶输入（0<del>+无穷）丶输出（1</del>+无穷）</p><p>算法的设计目标：正确性丶可读性丶健壮性丶算法效率与存储量需求（高效性）</p><p>算法分析方法：事后统计、事前分析估算</p><p>算法分析：时间复杂度丶空间复杂度</p><p>时间复杂度比较：O(1)＜O(log2n)＜O(n)＜O(nlog2n)＜O(n²)＜O(n³)&lt; O(2 n方)&lt; O(n!)&lt; O(nn方)</p></blockquote><h2 id="第二章·线性表"><a href="#第二章·线性表" class="headerlink" title="第二章·线性表"></a>第二章·线性表</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><blockquote><p>线性表是具有相同数据类型的n个(n＞=0)数据元素的有限序列，其中n为表长，当n=0时为空表，</p><p>除第一个元素外，每一个元素都有且仅有一个直接前驱，除最后一个元素外，每个元素都有且仅有一个直接后继</p></blockquote><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><blockquote><p>顺序表：是指逻辑上相邻的两个元素，在物理上也相邻</p><p>顺序表和链表的比较：顺序表可以随机存取也可以顺序存取；链表只能从表头顺序存取</p><p>使用数组定义线性表，要知道数组可以静态分配；也可以动态分配；动态分配使用malloc函数</p><p>顺序表的优点是：可随机存取，存储密度高；顺序表的缺点是：要求大片连续空间，改变容量不方便</p></blockquote><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><blockquote><p>在每个结点中除了包含数据之外，还包含一个指针域，用来指向其后继结点</p><p>带头结点的单链表头指针始终不等于NULL，head-&gt;next等于NULL时，链表为空</p><p>不带头结点的单链表头结点直接指向开始结点，head等于NULL时，链表为空</p><p>单链表的优点：不要求一大片连续的空间，改变容量方便；单链表的缺点：不可随机存取，要花费一定空间存放指针</p></blockquote><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><blockquote><p>带头结点的双链表，当head-&gt;next为NULL时链表为空</p><p>不带头结点的双链表，当head为NULL时链表为空</p><p>初始化时，双链表的前驱指针和后继指针都指向NULL</p></blockquote><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><blockquote><p>循环单链表和循环双链表都是由对应的单链表和双链表改造而来的，只要在终端结点和头结点(或开始结点)间建立联系即可。</p><p>循环双链表头结点（或开始结点）的prior指针指向终端结点；终端结点的next指针指向头结点</p><p>循环单链表（带头结点），head=head-&gt;next时，为空链表</p><p>循环单链表（不带头结点），head = NULL时，为空链表</p><p>循环双链表（带头结点），head = head-&gt;next 或 head = head-&gt;prior时，为空链表</p><p>循环双链表（不带头结点），head=NULL时，为空链表</p></blockquote><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><blockquote><p>静态链表：分配一整片连续的内存空间，各个结点集中安置</p><p>0号结点充当头结点，游标为-1表示最后一个结点</p><p>每个数据元素4B，每个游标4B，（每个结点共8B）设起始地址为addr；找某个元素的地址为：addr+8*下标</p></blockquote><h3 id="2、操作"><a href="#2、操作" class="headerlink" title="2、操作"></a>2、操作</h3><h4 id="顺序表-1"><a href="#顺序表-1" class="headerlink" title="顺序表"></a>顺序表</h4><h5 id="顺序表——静态分配"><a href="#顺序表——静态分配" class="headerlink" title="顺序表——静态分配"></a>顺序表——静态分配</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define MAXSIZE 10</span><br><span class="line">typedef struct &#123;</span><br><span class="line"> ElemType data[MAXSIZE];</span><br><span class="line"> int length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;基本操作——初始化一个顺序表</span><br><span class="line">void InitList(SqList &amp;L)&#123;</span><br><span class="line"> for(int i &#x3D; 0;i&lt;MAXSIZE;i++)</span><br><span class="line"> L.data[i] &#x3D; 0;</span><br><span class="line"> L.length &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"> SqList L;</span><br><span class="line"> InitList(L);</span><br><span class="line"> &#x2F;&#x2F;.....一系列操作</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="顺序表——动态分配"><a href="#顺序表——动态分配" class="headerlink" title="顺序表——动态分配"></a>顺序表——动态分配</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define INITSIZE 10 &#x2F;&#x2F;顺序表初始长度</span><br><span class="line">typedef struct &#123;</span><br><span class="line"> ElemType *data;</span><br><span class="line"> int MaxSize; &#x2F;&#x2F;顺序表的最大容量</span><br><span class="line"> int length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;基本操作——初始化一个顺序表</span><br><span class="line">void InitList(SeqList &amp;L)&#123;</span><br><span class="line"> L.data &#x3D; (ElemType *)malloc(sizeof(ElemType)*INITSIZE);</span><br><span class="line"> for(int i &#x3D; 0;i&lt;MAXSIZE;i++)</span><br><span class="line"> L.data[i] &#x3D; 0;</span><br><span class="line"> L.length &#x3D; 0;</span><br><span class="line"> L.MaxSize &#x3D; INITSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加动态数组的长度</span><br><span class="line">void IncreaseSize(SeqList &amp;L,int len)&#123;</span><br><span class="line"> int *p &#x3D; L.data;</span><br><span class="line"> L.data &#x3D; (int *)malloc((L.MaxSize+len)*sizeof(int));</span><br><span class="line"> for(int i &#x3D; 0;i&lt;L.length;i++)</span><br><span class="line"> L.data[i] &#x3D; p[i];</span><br><span class="line"> L.MaxSize &#x3D; L.MaxSize+len;</span><br><span class="line"> free(p);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"> SeqList L;</span><br><span class="line"> InitList(L);</span><br><span class="line"> &#x2F;&#x2F;.....一系列操作</span><br><span class="line"> IncreaseSize(L,5);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;插入操作</span><br><span class="line">bool InsertList(SqList &amp;L,int e,int i)&#123;</span><br><span class="line"> if(i&lt;1 || i&gt;L.length+1)</span><br><span class="line"> return false;</span><br><span class="line"> if(L.length&gt;&#x3D;MAXSIZE)</span><br><span class="line"> return false;</span><br><span class="line"> for(int j &#x3D; L.length;j&gt;&#x3D;i;j--)</span><br><span class="line"> L.data[j] &#x3D; L.data[j-1];</span><br><span class="line"> L.data[i-1] &#x3D; e;</span><br><span class="line"> L.length++;</span><br><span class="line"> return true;</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度为：O(n)</span><br></pre></td></tr></table></figure><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除操作</span><br><span class="line">bool DeleteList(SqList &amp;L,int i,int &amp;e)&#123;</span><br><span class="line"> if(i&lt;1||i&gt;L.length)</span><br><span class="line"> return false;</span><br><span class="line"> e &#x3D; L.data[i-1];</span><br><span class="line"> for(int j &#x3D; i;j&lt;&#x3D;L.length;j++)</span><br><span class="line"> L.data[j-1] &#x3D; L.data[j];</span><br><span class="line"> L.length--;</span><br><span class="line"> return true;</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度为：O(n)</span><br></pre></td></tr></table></figure><h5 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;按位查找</span><br><span class="line"> int GetElem(SqList L,int i)&#123;</span><br><span class="line">  return L.data[i-1];</span><br><span class="line"> &#125; </span><br><span class="line">时间复杂度：O(1)</span><br></pre></td></tr></table></figure><h5 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;按值查找</span><br><span class="line"> int LocateElem(SqList L,int e)&#123;</span><br><span class="line">  for(int i &#x3D; 0;i&lt;L.length;i++)</span><br><span class="line">  if(L.data[i]&#x3D;&#x3D;e)</span><br><span class="line">  return i+1;</span><br><span class="line">  return 0;</span><br><span class="line"> &#125;</span><br><span class="line">时间复杂度：最好O(1)</span><br><span class="line"> 最坏O(n)</span><br><span class="line"> 平均O(n)</span><br></pre></td></tr></table></figure><h4 id="单链表-1"><a href="#单链表-1" class="headerlink" title="单链表"></a>单链表</h4>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
